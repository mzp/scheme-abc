# Arith
Add_i: op=0xc5; stack= ~-1
Subtract_i: op=0xc6; stack= ~-1
Multiply_i: op=0xc7; stack= ~-1
Divide: op=0xa3; stack= ~-1

# predicator
Equals: op=0xab; stack= ~-1
StrictEquals: op=0xac; stack= ~-1
LessThan: op=0xad; stack= ~-1
LessEquals: op=0xae; stack= ~-1
GreaterThan: op=0xaf; stack= ~-1
GreaterEquals: op=0xb0; stack= ~-1

# if
Label of Label.t: op=0x09; prefix=const [label arg0]
IfNlt of Label.t: op=0x0c; stack= ~-1; args=const [label_ref arg0]
IfNle of Label.t: op=0x0d; stack= ~-1; args=const [label_ref arg0]
IfNgt of Label.t: op=0x0e; stack= ~-1; args=const [label_ref arg0]
IfNge of Label.t: op=0x0f; stack= ~-1; args=const [label_ref arg0]
Jump of Label.t:  op=0x10; args=const [label_ref arg0]
IfTrue of Label.t: op=0x11; stack= ~-1; args=const [label_ref arg0]
IfFalse of Label.t: op=0x12; stack= ~-1; args=const [label_ref arg0]
IfEq of Label.t: op=0x13; stack= ~-1; args=const [label_ref arg0]
IfNe of Label.t: op=0x14; stack= ~-1; args=const [label_ref arg0]
IfLt of Label.t: op=0x15; stack= ~-1; args=const [label_ref arg0]
IfLe of Label.t: op=0x16; stack= ~-1; args=const [label_ref arg0]
IfGt of Label.t: op=0x17; stack= ~-1; args=const [label_ref arg0]
IfGe of Label.t: op=0x18; stack= ~-1; args=const [label_ref arg0]
IfStrictEq of Label.t: op=0x19; stack= ~-1; args=const [label_ref arg0]
IfStrictNe of Label.t: op=0x1a; stack= ~-1; args=const [label_ref arg0]

# literal
PushTrue: op=0x26; stack=1
PushFalse: op=0x27; stack=1
PushString of string: op=0x2C; stack=1; const=string arg0; args=fun (cmap,_) -> [string_get arg0 cmap]
PushInt of int: op=0x2D; stack=1; const=int arg0; args=fun (cmap,_) -> [int_get arg0 cmap]
PushScope: op=0x30; stack= ~-1; scope=1

# scope
GetLocal_0: op=0xD0; stack=1
GetLocal_1: op=0xD1; stack=1
GetLocal_2: op=0xD2; stack=1
GetLocal_3: op=0xD3; stack=1
GetLocal of int: op=0x62; stack=1; args=const [u30 arg0]
SetLocal_0: op=0xD4; stack=1
SetLocal_1: op=0xD5; stack=1
SetLocal_2: op=0xD6; stack=1
SetLocal_3: op=0xD7; stack=1
SetLocal of int: op=0x63; stack=1; args=const [u30 arg0]
GetGlobalScope:op=0x64; stack=1
GetScopeObject of int:op=0x65; stack=1; args=const[u8 arg0]
GetSlot of int:op=0x6c; args=const [u30 arg0]
SetSlot of int:op=0x6d; stack= ~-2; args=const [u30 arg0]
GetGlobalSlot of int:op=0x6e; stack=1; args=const [u30 arg0]
SetGlobalSlot of int:op=0x6f; stack= ~-1; args=const [u30 arg0]

GetProperty of Cpool.multiname: op=0x66; const=multiname arg0; args=fun (cmap,_) ->[multiname_get arg0 cmap]

ReturnVoid: op=0x47
FindPropStrict of Cpool.multiname: op=0x5D; stack=1; const=multiname arg0; args=fun (cmap,_) ->[multiname_get arg0 cmap]
PushUInt of int: op=0x2E; stack=1; const=uint arg0; args=fun (cmap,_) -> [uint_get arg0 cmap]
CallPropLex of Cpool.multiname * int: op=0x4c; stack= ~-arg1; args=fun (cmap,_) ->[multiname_get arg0 cmap;Bytes.u30 arg1]
Pop: op=0x29; stack= ~-1
Swap:op=0x2b
PopScope:op=0x1d; scope= ~-1

NewObject of int:op=0x55; args=const [u30 arg0]
NewArray of int:op=0x56; args=const [u30 arg0]
NewFunction of meth: op=0x40; meth=Some arg0; args=fun (_,mmap)->[Bytes.u30 (Pool.get arg0 mmap)]
