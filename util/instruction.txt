# Arith
Add_i: op=0xc5; stack= ~-1
Subtract_i: op=0xc6; stack= ~-1
Multiply_i: op=0xc7; stack= ~-1
Divide: op=0xa3; stack= ~-1

Add: op=0xa0; stack= ~-1
Subtract: op=0xa1; stack= ~-1
Multiply: op=0xa2; stack= ~-1

# predicator
Equals: op=0xab; stack= ~-1
StrictEquals: op=0xac; stack= ~-1
LessThan: op=0xad; stack= ~-1
LessEquals: op=0xae; stack= ~-1
GreaterThan: op=0xaf; stack= ~-1
GreaterEquals: op=0xb0; stack= ~-1

# if
Label of Label.t: op=0x09; prefix=const [label arg0]
IfNlt of Label.t: op=0x0c; stack= ~-1; args=const [label_ref arg0]
IfNle of Label.t: op=0x0d; stack= ~-1; args=const [label_ref arg0]
IfNgt of Label.t: op=0x0e; stack= ~-1; args=const [label_ref arg0]
IfNge of Label.t: op=0x0f; stack= ~-1; args=const [label_ref arg0]
Jump of Label.t:  op=0x10; args=const [label_ref arg0]
IfTrue of Label.t: op=0x11; stack= ~-1; args=const [label_ref arg0]
IfFalse of Label.t: op=0x12; stack= ~-1; args=const [label_ref arg0]
IfEq of Label.t: op=0x13; stack= ~-1; args=const [label_ref arg0]
IfNe of Label.t: op=0x14; stack= ~-1; args=const [label_ref arg0]
IfLt of Label.t: op=0x15; stack= ~-1; args=const [label_ref arg0]
IfLe of Label.t: op=0x16; stack= ~-1; args=const [label_ref arg0]
IfGt of Label.t: op=0x17; stack= ~-1; args=const [label_ref arg0]
IfGe of Label.t: op=0x18; stack= ~-1; args=const [label_ref arg0]
IfStrictEq of Label.t: op=0x19; stack= ~-1; args=const [label_ref arg0]
IfStrictNe of Label.t: op=0x1a; stack= ~-1; args=const [label_ref arg0]

# literal
PushNull:             op=0x20; stack=1
PushUndefined:        op=0x21; stack=1
PushByte of int:      op=0x24; stack=1; args=const [Bytes.u8  arg0]
PushShort of int:     op=0x25; stack=1; args=const [Bytes.u30 arg0]
PushTrue:             op=0x26; stack=1
PushFalse:            op=0x27; stack=1
PushNaN:              op=0x28; stack=1
PushString of string: op=0x2C; stack=1; const=string arg0; args=fun {cpool=cpool} -> [string_get arg0 cpool]
PushInt of int:       op=0x2D; stack=1; const=int arg0;    args=fun {cpool=cpool} -> [int_get arg0 cpool]
PushUInt of int:      op=0x2E; stack=1; const=uint arg0;   args=fun {cpool=cpool} -> [uint_get arg0 cpool]
PushDouble of float:  op=0x2F; stack=1; const=double arg0; args=fun {cpool=cpool} -> [double_get arg0 cpool]
PushNamespace of Cpool.namespace: op=0x31; stack=1; const=namespace arg0; args=fun {cpool=cpool} -> [namespace_get arg0 cpool]
PushScope:            op=0x30; stack= ~-1; scope=1
PushWith:             op=0x1c; stack= ~-1; scope=1

# scope
GetLocal_0: op=0xD0; stack=1;count=1
GetLocal_1: op=0xD1; stack=1;count=2
GetLocal_2: op=0xD2; stack=1;count=3
GetLocal_3: op=0xD3; stack=1;count=4
GetLocal of int: op=0x62; stack=1; args=const [Bytes.u30 arg0];count=(arg0+1)
SetLocal_0: op=0xD4; stack=1
SetLocal_1: op=0xD5; stack=1
SetLocal_2: op=0xD6; stack=1
SetLocal_3: op=0xD7; stack=1
SetLocal of int: op=0x63; stack=1; args=const [Bytes.u30 arg0]
GetGlobalScope:op=0x64; stack=1
GetScopeObject of int:op=0x65; stack=1; args=const[Bytes.u8 arg0]
GetSlot of int:op=0x6c; args=const [Bytes.u30 arg0]
SetSlot of int:op=0x6d; stack= ~-2; args=const [Bytes.u30 arg0]
GetGlobalSlot of int:op=0x6e; stack=1; args=const [Bytes.u30 arg0]
SetGlobalSlot of int:op=0x6f; stack= ~-1; args=const [Bytes.u30 arg0]
GetLex of Cpool.multiname:op=0x60; stack=1; const=multiname arg0; args=fun {cpool=cmap} ->[multiname_get arg0 cmap]
GetProperty of Cpool.multiname: op=0x66; const=multiname arg0; args=fun {cpool=cmap} ->[multiname_get arg0 cmap]
SetProperty of Cpool.multiname: op=0x61; stack= ~-2; const=multiname arg0; args=fun {cpool=cmap} ->[multiname_get arg0 cmap];

ReturnVoid: op=0x47
ReturnValue: op=0x48; stack= ~-1
FindPropStrict of Cpool.multiname: op=0x5D; stack=1; const=multiname arg0; args=fun {cpool=cmap} ->[multiname_get arg0 cmap]
CallPropLex of Cpool.multiname * int: op=0x4c; stack= 1-arg1; const=multiname arg0;args=fun {cpool=cmap} ->[multiname_get arg0 cmap;Bytes.u30 arg1]
Call of int: op=0x41; stack= 1-(2+arg0); args=const [Bytes.u30 arg0];
Pop: op=0x29; stack= ~-1
Swap:op=0x2b
PopScope:op=0x1d; scope= ~-1

NewObject of int:op=0x55; args=const [Bytes.u30 arg0]; stack=1-arg0
NewArray of int:op=0x56; args=const [Bytes.u30 arg0]
NewActivation:op=0x57; stack=1
NewFunction of meth: op=0x40; stack=1; meth=[arg0]; args=fun {meths=meths}->[Bytes.u30 (index arg0 meths)]

Dup: op=0x2a; stack= 2

NewClass of klass:op=0x58; klass=Some arg0; meth=(arg0.cinit::arg0.iinit::arg0.methods); args=(fun {klasses=klasses} -> [Bytes.u30 (index arg0 klasses)])
